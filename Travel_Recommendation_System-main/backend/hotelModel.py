# # -*- coding: utf-8 -*-
# """HotelRecommendationmodel.ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/162bc-_7Drqv1jIsLs3cUFxtszYdjb54v
# """

# import pandas as pd
# import numpy as np
# from sklearn.metrics.pairwise import cosine_similarity
# from sklearn.preprocessing import LabelEncoder
# from sklearn.decomposition import TruncatedSVD
# from scipy.sparse import csr_matrix

# data=pd.read_csv("hotelDataset.csv")

# """# Step 1: Preprocessing"""

# label_state=LabelEncoder()
# label_city=LabelEncoder()
# data['state']=label_state.fit_transform(data['state'])
# data['city']=label_city.fit_transform(data['city'])



# facilities=['Spa','Airport shuttle', 'Private Lounge', 'Business Center',
#        'Contactless check', 'Pool', 'Pet friendly', 'Free Wifi',
#        'Wheel-chair accessible', 'Complementary breakfast',
#        'Fitness Center', '24 hr front desk', 'Valet Parking',
#        'Open bar', 'Child Friendly', 'smoking']

# data[facilities] = data[facilities].apply(pd.to_numeric, errors='coerce', downcast='integer')

# data['rating'] = data['HotelRating']
# hotel_features = data[['state', 'city'] + facilities + ['rating']]

# # Normalize the feature vector (optional)
# hotel_features_norm = (hotel_features - hotel_features.mean()) / hotel_features.std()

# cos_sim = cosine_similarity(hotel_features_norm)

# # Step 4: Collaborative Filtering (Matrix Factorization)
# interaction_matrix = pd.pivot_table(data, index='HotelName', columns='state', values='HotelRating', aggfunc='count', fill_value=0)
# interaction_matrix_sparse = csr_matrix(interaction_matrix)

# svd = TruncatedSVD(n_components=5)
# svd_matrix = svd.fit_transform(interaction_matrix_sparse)

# item_item_similarity = cosine_similarity(svd_matrix)

# # Step 5: Hybrid Recommendation System (for Real-Time Input)
# def hybrid_recommendation(user_state, user_city, user_facilities, alpha=0.7):
#     # Step 5.1: Filter hotels based on user input (state, city, facilities)
#     filtered_hotels = data[
#         (data['state'] == label_state.transform([user_state])[0]) &
#         (data['city'] == label_city.transform([user_city])[0])
#     ]

#     # Check facilities
#     for facility in user_facilities:
#         filtered_hotels = filtered_hotels[filtered_hotels[facility] == 1]

#     # Step 5.2: Content-based filtering (Cosine similarity score)
#     filtered_hotel_indices = filtered_hotels.index
#     content_scores = cos_sim[filtered_hotel_indices].mean(axis=1)

#     # Step 5.3: Collaborative filtering (Item-item similarity score)
#     collaborative_scores = item_item_similarity[filtered_hotel_indices].mean(axis=1)

#     # Step 5.4: Combine the scores using weighted hybrid method
#     final_scores = alpha * content_scores + (1 - alpha) * collaborative_scores

#     # Sort by final score (descending order)
#     sorted_indices = np.argsort(final_scores)[::-1]

#     # Step 5.5: Return the top N recommendations (top 5 for example)
#     top_recommendations = filtered_hotels.iloc[sorted_indices[:5]]

#     return top_recommendations[['HotelName', 'state', 'city', 'HotelRating']]

# # Example Usage (Real-Time Input)
# user_state = 'TN'  # Input from user
# user_city = 'antioch'  # Input from user
# user_facilities = ['Spa', 'Fitness Center']  # Input from user (facilities they want)

# recommendations = hybrid_recommendation(user_state, user_city, user_facilities, alpha=0.7)
# print(recommendations)

# import numpy as np

# # Step 5: Hybrid Recommendation System (for Real-Time Input)
# def hybrid_recommendation(user_state, user_city, user_facilities, alpha=0.7, top_n=3):
#     # Step 5.1: Filter hotels based on user input (state, city, facilities)

#     # Ensure the states and cities are transformed correctly (handle unseen states/cities)
#     try:
#         transformed_state = label_state.transform([user_state])[0]
#         transformed_city = label_city.transform([user_city])[0]
#     except ValueError:
#         raise ValueError(f"Unrecognized state '{user_state}' or city '{user_city}'.")

#     # Filter by state and city
#     filtered_hotels = data[
#         (data['state'] == transformed_state) &
#         (data['city'] == transformed_city)
#     ]

#     # Check facilities - Relax the condition to allow hotels with at least one matching facility
#     if user_facilities:
#         filtered_hotels = filtered_hotels[filtered_hotels[user_facilities].sum(axis=1) > 0]

#     # If no hotels match the filters, provide a fallback
#     if filtered_hotels.empty:
#         print("No hotels match your criteria. Expanding the search with less restrictive filters.")
#         # Fallback: Relax facility filtering or use only state/city criteria
#         filtered_hotels = data[
#             (data['state'] == transformed_state) &
#             (data['city'] == transformed_city)
#         ]
#         if filtered_hotels.empty:
#             # If no hotels match state and city, try the entire state
#             filtered_hotels = data[data['state'] == transformed_state]
#             print("No hotels found in the city, expanding search to the entire state.")

#     # Step 5.2: Content-based filtering (Cosine similarity score)
#     # Get the indices of the filtered hotels
#     filtered_hotel_indices = filtered_hotels.index

#     # Calculate content-based scores (average similarity across all filtered hotels)
#     content_scores = cos_sim[filtered_hotel_indices].mean(axis=1)

#     # Step 5.3: Collaborative filtering (Item-item similarity score)
#     collaborative_scores = item_item_similarity[filtered_hotel_indices].mean(axis=1)

#     # Step 5.4: Combine the scores using a weighted hybrid method
#     final_scores = alpha * content_scores + (1 - alpha) * collaborative_scores

#     # Sort by final score (highest score first)
#     sorted_indices = np.argsort(final_scores)[::-1]

#     # Step 5.5: Ensure at least 3 recommendations (top 3 for example)
#     top_n_recommendations = sorted_indices[:max(top_n, 3)]  # Ensure at least 3 hotels

#     # If fewer than 3 recommendations exist, return all available hotels
#     if len(top_n_recommendations) < 3:
#         print("Warning: Less than 3 recommendations found. Returning all available.")
#         top_n_recommendations = sorted_indices[:len(filtered_hotels)]  # Return all available

#     # Return the top N recommendations (at least 3)
#     top_recommendations = filtered_hotels.iloc[top_n_recommendations]

#     return top_recommendations[['HotelName', 'state', 'city', 'HotelRating']]

# # Example Usage (Real-Time Input)
# user_state = 'MO'  # Input from user
# user_city = 'bridgeton'  # Input from user
# user_facilities = ['Spa', 'Fitness Center']  # Input from user (facilities they want)

# recommendations = hybrid_recommendation(user_state, user_city, user_facilities, alpha=0.7, top_n=3)
# print(recommendations)

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import LabelEncoder

# Load your dataset
data = pd.read_csv("hotelDataset.csv")

# Data Preprocessing
label_state = LabelEncoder()
label_city = LabelEncoder()

data['state'] = label_state.fit_transform(data['state'])
data['city'] = label_city.fit_transform(data['city'])

facilities = ['Spa', 'Airport shuttle', 'Business Center', 'Contactless check',
              'Pool', 'Pet friendly', 'Free Wifi', 'Wheel-chair accessible', 'Complementary breakfast',
              'Fitness Center', '24 hr front desk', 'Valet Parking', 'Open bar', 'smoking']

# data[facilities] = data[facilities].apply(pd.to_numeric, errors='coerce', downcast='integer')

# Cosine similarity for content-based filtering
hotel_features = data[['state', 'city'] + facilities + ['HotelRating']]
hotel_features_norm = (hotel_features - hotel_features.mean()) / hotel_features.std()
cos_sim = cosine_similarity(hotel_features_norm)

# Hybrid Recommendation System (Real-Time Input)
def hybrid_recommendation(user_state, user_city, user_facilities, alpha=0.7, top_n=3):
    try:
        transformed_state = label_state.transform([user_state])[0]
        transformed_city = label_city.transform([user_city])[0]
    except ValueError:
        raise ValueError(f"Unrecognized state '{user_state}' or city '{user_city}'.")

    # Filtering hotels based on state, city, and facilities
    filtered_hotels = data[(data['state'] == transformed_state) & (data['city'] == transformed_city)]

    if user_facilities:
        filtered_hotels = filtered_hotels[filtered_hotels[user_facilities].sum(axis=1) > 0]

    if filtered_hotels.empty:
        filtered_hotels = data[(data['state'] == transformed_state) & (data['city'] == transformed_city)]

    # Calculate the content-based filtering scores
    filtered_hotel_indices = filtered_hotels.index
    content_scores = cos_sim[filtered_hotel_indices].mean(axis=1)

    final_scores = content_scores
    sorted_indices = np.argsort(final_scores)[::-1]

    # Get the top N recommendations
    top_n_recommendations = sorted_indices[:max(top_n, 3)]
    top_recommendations = filtered_hotels.iloc[top_n_recommendations]

    top_recommendations['state'] = label_state.inverse_transform(top_recommendations['state'])
    top_recommendations['city'] = label_city.inverse_transform(top_recommendations['city'])
    

    # Convert DataFrame to list of dictionaries before returning
    return top_recommendations[['HotelName', 'HotelWebsite', 'HotelRating','Address',]].to_dict(orient='records')

# def hybrid_recommendation(user_state, user_city, user_facilities, alpha=0.7, top_n=3):
#     try:
#         # Ensure valid state and city transformation
#         transformed_state = label_state.transform([user_state])[0]
#         transformed_city = label_city.transform([user_city])[0]
#     except ValueError:
#         raise ValueError(f"Unrecognized state '{user_state}' or city '{user_city}'.")

#     # Step 1: Filter hotels based on state and city
#     filtered_hotels = data[(data['state'] == transformed_state) & (data['city'] == transformed_city)]

#     # Step 2: Apply facility filtering
#     if user_facilities:
#         # Filter hotels based on user-selected facilities (only if the facility column exists)
#         available_facilities = [facility for facility in user_facilities if facility in filtered_hotels.columns]
#         if available_facilities:
#             # Match hotels based on the available facilities
#             filtered_hotels['facility_match_count'] = filtered_hotels[available_facilities].sum(axis=1)
#             filtered_hotels = filtered_hotels[filtered_hotels['facility_match_count'] > 0]
#         else:
#             print(f"Warning: None of the requested facilities ({user_facilities}) are available in the dataset.")
#             # No facilities matched, consider skipping facility filtering
#             filtered_hotels = filtered_hotels  # or apply fallback logic if desired

#     # If no hotels match, fallback to all hotels in the same state and city
#     if filtered_hotels.empty:
#         filtered_hotels = data[(data['state'] == transformed_state) & (data['city'] == transformed_city)]

#     # Step 3: Calculate content-based scores (cosine similarity or other method)
#     filtered_hotel_indices = filtered_hotels.index
#     content_scores = cos_sim[filtered_hotel_indices].mean(axis=1)  # or use other scoring metrics

#     # Step 4: Calculate final scores and sort hotels
#     # Use alpha to blend content-based and facility-based scores
#     filtered_hotels['final_score'] = (alpha * content_scores) + ((1 - alpha) * filtered_hotels['facility_match_count'])

#     # Sort hotels by final score (descending order)
#     sorted_indices = np.argsort(filtered_hotels['final_score'])[::-1]

#     # Step 5: Get the top N recommendations
#     top_n_recommendations = sorted_indices[:max(top_n, 3)]
#     top_recommendations = filtered_hotels.iloc[top_n_recommendations]

#     # Step 6: Inverse transform the state and city back to their original labels
#     top_recommendations['state'] = label_state.inverse_transform(top_recommendations['state'])
#     top_recommendations['city'] = label_city.inverse_transform(top_recommendations['city'])

#     # Return a list of hotel recommendations as dictionaries
#     return top_recommendations[['HotelName', 'HotelWebsite', 'HotelRating', 'Address']].to_dict(orient='records')

# Step 2: Apply facility filtering
def hybrid_recommendation(user_state, user_city, user_facilities, alpha=0.7, top_n=3):
    try:
        transformed_state = label_state.transform([user_state])[0]
        transformed_city = label_city.transform([user_city])[0]
    except ValueError:
        raise ValueError(f"Unrecognized state '{user_state}' or city '{user_city}'.")

    # Filter hotels based on state and city
    filtered_hotels = data[(data['state'] == transformed_state) & (data['city'] == transformed_city)]
    
    if user_facilities:
        available_facilities = [facility for facility in user_facilities if facility in filtered_hotels.columns]
        if available_facilities:
            match_scores = filtered_hotels[available_facilities].sum(axis=1)
            filtered_hotels['facility_match_score'] = match_scores / len(available_facilities)
        else:
            print(f"Warning: None of the requested facilities are available in the dataset.")
            filtered_hotels['facility_match_score'] = 0
    else:
        filtered_hotels['facility_match_score'] = 0

    if filtered_hotels.empty:
        filtered_hotels = data[(data['state'] == transformed_state) & (data['city'] == transformed_city)]
        print("Expanding search to include all hotels in the state and city.")

    filtered_hotel_indices = filtered_hotels.index
    content_scores = cos_sim[filtered_hotel_indices].mean(axis=1)  # or use other scoring metrics
    filtered_hotels['content_score'] = content_scores / content_scores.max()

    # Calculate final score
    filtered_hotels['final_score'] = alpha * filtered_hotels['content_score'] + (1 - alpha) * filtered_hotels['facility_match_score']
    
    # Sort hotels by final score
    filtered_hotels_sorted = filtered_hotels.sort_values(by='final_score', ascending=False)

    # Get the top n recommendations (if less than n, it will return fewer results)
    top_n_recommendations = filtered_hotels_sorted.head(top_n)
    
    # Inverse transform the state and city for human-readable format
    top_n_recommendations['state'] = label_state.inverse_transform(top_n_recommendations['state'])
    top_n_recommendations['city'] = label_city.inverse_transform(top_n_recommendations['city'])

    return top_n_recommendations[['HotelName', 'HotelWebsite', 'HotelRating', 'Address']].to_dict(orient='records')
